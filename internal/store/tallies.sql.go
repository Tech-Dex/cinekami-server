// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tallies.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountTalliesByMovie = `-- name: CountTalliesByMovie :one
SELECT COUNT(*) FROM vote_tallies WHERE movie_id = $1
`

func (q *Queries) CountTalliesByMovie(ctx context.Context, movieID int64) (int64, error) {
	row := q.db.QueryRow(ctx, CountTalliesByMovie, movieID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetTalliesByMovie = `-- name: GetTalliesByMovie :many
SELECT movie_id, category, count
FROM vote_tallies
WHERE movie_id = $1
`

func (q *Queries) GetTalliesByMovie(ctx context.Context, movieID int64) ([]VoteTally, error) {
	rows, err := q.db.Query(ctx, GetTalliesByMovie, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VoteTally{}
	for rows.Next() {
		var i VoteTally
		if err := rows.Scan(&i.MovieID, &i.Category, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTalliesForMovies = `-- name: GetTalliesForMovies :many
WITH cats AS (
  SELECT unnest(enum_range(NULL::vote_category))::vote_category AS category
), mids AS (
  SELECT unnest($1::bigint[]) AS movie_id
)
SELECT m.movie_id,
       c.category::text AS category,
       COALESCE(t.count, 0) AS count
FROM mids m
CROSS JOIN cats c
LEFT JOIN vote_tallies t ON t.movie_id = m.movie_id AND t.category = c.category
ORDER BY m.movie_id, c.category
`

type GetTalliesForMoviesRow struct {
	MovieID  interface{} `json:"movie_id"`
	Category string      `json:"category"`
	Count    int64       `json:"count"`
}

func (q *Queries) GetTalliesForMovies(ctx context.Context, dollar_1 []int64) ([]GetTalliesForMoviesRow, error) {
	rows, err := q.db.Query(ctx, GetTalliesForMovies, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTalliesForMoviesRow{}
	for rows.Next() {
		var i GetTalliesForMoviesRow
		if err := rows.Scan(&i.MovieID, &i.Category, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const IncrementTally = `-- name: IncrementTally :exec
INSERT INTO vote_tallies (movie_id, category, count)
VALUES ($1, $2, 1)
ON CONFLICT (movie_id, category) DO UPDATE SET count = vote_tallies.count + 1
`

type IncrementTallyParams struct {
	MovieID  int64  `json:"movie_id"`
	Category string `json:"category"`
}

func (q *Queries) IncrementTally(ctx context.Context, arg IncrementTallyParams) error {
	_, err := q.db.Exec(ctx, IncrementTally, arg.MovieID, arg.Category)
	return err
}

const ListTalliesByMoviePage = `-- name: ListTalliesByMoviePage :many
SELECT movie_id, category, count
FROM vote_tallies
WHERE movie_id = $1
  AND (
    $3::text = '' OR (count < $2) OR (count = $2 AND category::text > $3)
  )
ORDER BY count DESC, category ASC
LIMIT $4
`

type ListTalliesByMoviePageParams struct {
	MovieID int64       `json:"movie_id"`
	Count   pgtype.Int8 `json:"count"`
	Column3 string      `json:"column_3"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) ListTalliesByMoviePage(ctx context.Context, arg ListTalliesByMoviePageParams) ([]VoteTally, error) {
	rows, err := q.db.Query(ctx, ListTalliesByMoviePage,
		arg.MovieID,
		arg.Count,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VoteTally{}
	for rows.Next() {
		var i VoteTally
		if err := rows.Scan(&i.MovieID, &i.Category, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
