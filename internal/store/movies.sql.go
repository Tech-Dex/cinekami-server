// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: movies.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountActiveMovies = `-- name: CountActiveMovies :one
SELECT COUNT(*)
FROM movies
WHERE release_date >= date_trunc('month', $1::timestamptz)::date
  AND $1::timestamptz <= (release_date + interval '14 days')
`

func (q *Queries) CountActiveMovies(ctx context.Context, dollar_1 pgtype.Timestamptz) (int64, error) {
	row := q.db.QueryRow(ctx, CountActiveMovies, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetMovieReleaseDate = `-- name: GetMovieReleaseDate :one
SELECT release_date
FROM movies
WHERE id = $1
`

func (q *Queries) GetMovieReleaseDate(ctx context.Context, id int64) (pgtype.Date, error) {
	row := q.db.QueryRow(ctx, GetMovieReleaseDate, id)
	var release_date pgtype.Date
	err := row.Scan(&release_date)
	return release_date, err
}

const HasAnyMovies = `-- name: HasAnyMovies :one
SELECT EXISTS (SELECT 1 FROM movies LIMIT 1) AS exists
`

func (q *Queries) HasAnyMovies(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, HasAnyMovies)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const ListActiveMoviesPage = `-- name: ListActiveMoviesPage :many
SELECT id, title, release_date, overview, poster_path, backdrop_path, popularity
FROM movies
WHERE release_date >= date_trunc('month', $1::timestamptz)::date
  AND $1::timestamptz <= (release_date + interval '14 days')
  AND (
    $3::bigint = 0 OR (popularity < $2) OR (popularity = $2 AND id < $3)
  )
ORDER BY popularity DESC, id DESC
LIMIT $4
`

type ListActiveMoviesPageParams struct {
	Column1    pgtype.Timestamptz `json:"column_1"`
	Popularity pgtype.Float8      `json:"popularity"`
	Column3    int64              `json:"column_3"`
	Limit      int32              `json:"limit"`
}

type ListActiveMoviesPageRow struct {
	ID           int64         `json:"id"`
	Title        string        `json:"title"`
	ReleaseDate  pgtype.Date   `json:"release_date"`
	Overview     pgtype.Text   `json:"overview"`
	PosterPath   pgtype.Text   `json:"poster_path"`
	BackdropPath pgtype.Text   `json:"backdrop_path"`
	Popularity   pgtype.Float8 `json:"popularity"`
}

func (q *Queries) ListActiveMoviesPage(ctx context.Context, arg ListActiveMoviesPageParams) ([]ListActiveMoviesPageRow, error) {
	rows, err := q.db.Query(ctx, ListActiveMoviesPage,
		arg.Column1,
		arg.Popularity,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveMoviesPageRow{}
	for rows.Next() {
		var i ListActiveMoviesPageRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ReleaseDate,
			&i.Overview,
			&i.PosterPath,
			&i.BackdropPath,
			&i.Popularity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMovieIDsByMonth = `-- name: ListMovieIDsByMonth :many
SELECT id
FROM movies
WHERE release_date >= date_trunc('month', $1::date)
  AND release_date <  (date_trunc('month', $1::date) + interval '1 month')
ORDER BY id
`

func (q *Queries) ListMovieIDsByMonth(ctx context.Context, dollar_1 pgtype.Date) ([]int64, error) {
	rows, err := q.db.Query(ctx, ListMovieIDsByMonth, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpsertMovie = `-- name: UpsertMovie :exec
INSERT INTO movies (id, title, release_date, overview, poster_path, backdrop_path, popularity)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (id) DO UPDATE SET
  title = EXCLUDED.title,
  release_date = EXCLUDED.release_date,
  overview = EXCLUDED.overview,
  poster_path = EXCLUDED.poster_path,
  backdrop_path = EXCLUDED.backdrop_path,
  popularity = EXCLUDED.popularity,
  updated_at = now()
`

type UpsertMovieParams struct {
	ID           int64         `json:"id"`
	Title        string        `json:"title"`
	ReleaseDate  pgtype.Date   `json:"release_date"`
	Overview     pgtype.Text   `json:"overview"`
	PosterPath   pgtype.Text   `json:"poster_path"`
	BackdropPath pgtype.Text   `json:"backdrop_path"`
	Popularity   pgtype.Float8 `json:"popularity"`
}

func (q *Queries) UpsertMovie(ctx context.Context, arg UpsertMovieParams) error {
	_, err := q.db.Exec(ctx, UpsertMovie,
		arg.ID,
		arg.Title,
		arg.ReleaseDate,
		arg.Overview,
		arg.PosterPath,
		arg.BackdropPath,
		arg.Popularity,
	)
	return err
}
