// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: movies.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountActiveMovies = `-- name: CountActiveMovies :one
SELECT COUNT(*)
FROM movies
WHERE release_date >= date_trunc('month', $1::timestamptz)::date
  AND release_date <= (date_trunc('month', $1::timestamptz)::date + interval '1 month - 1 second')
  AND $1::timestamptz <= (release_date + interval '14 days')
`

func (q *Queries) CountActiveMovies(ctx context.Context, dollar_1 pgtype.Timestamptz) (int64, error) {
	row := q.db.QueryRow(ctx, CountActiveMovies, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountActiveMoviesFiltered = `-- name: CountActiveMoviesFiltered :one
SELECT COUNT(*)
FROM movies
WHERE release_date >= date_trunc('month', $1::timestamptz)::date
  AND release_date <= (date_trunc('month', $1::timestamptz)::date + interval '1 month - 1 second')
  AND $1::timestamptz <= (release_date + interval '14 days')
  AND ($2::float8 IS NULL OR popularity >= $2)
  AND ($3::float8 IS NULL OR popularity <= $3)
`

type CountActiveMoviesFilteredParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 float64            `json:"column_2"`
	Column3 float64            `json:"column_3"`
}

func (q *Queries) CountActiveMoviesFiltered(ctx context.Context, arg CountActiveMoviesFilteredParams) (int64, error) {
	row := q.db.QueryRow(ctx, CountActiveMoviesFiltered, arg.Column1, arg.Column2, arg.Column3)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetMovieReleaseDate = `-- name: GetMovieReleaseDate :one
SELECT release_date
FROM movies
WHERE id = $1
`

func (q *Queries) GetMovieReleaseDate(ctx context.Context, id int64) (pgtype.Date, error) {
	row := q.db.QueryRow(ctx, GetMovieReleaseDate, id)
	var release_date pgtype.Date
	err := row.Scan(&release_date)
	return release_date, err
}

const HasAnyMovies = `-- name: HasAnyMovies :one
SELECT EXISTS (SELECT 1 FROM movies LIMIT 1) AS exists
`

func (q *Queries) HasAnyMovies(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, HasAnyMovies)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const ListActiveMoviesFilteredPage = `-- name: ListActiveMoviesFilteredPage :many
WITH base AS (
  SELECT id, title, release_date, overview, poster_path, backdrop_path, popularity, imdb_url, cinemagia_url
  FROM movies
  WHERE release_date >= date_trunc('month', $1::timestamptz)::date
    AND release_date <= (date_trunc('month', $1::timestamptz)::date + interval '1 month - 1 second')
    AND $1::timestamptz <= (release_date + interval '14 days')
    AND ($2::float8 IS NULL OR popularity >= $2)
    AND ($3::float8 IS NULL OR popularity <= $3)
), t AS (
  SELECT movie_id,
         SUM(CASE WHEN category = 'solo_friends' THEN count ELSE 0 END)::bigint AS solo_friends,
         SUM(CASE WHEN category = 'couple' THEN count ELSE 0 END)::bigint AS couple,
         SUM(CASE WHEN category = 'streaming' THEN count ELSE 0 END)::bigint AS streaming,
         SUM(CASE WHEN category = 'arr' THEN count ELSE 0 END)::bigint AS arr
  FROM vote_tallies
  GROUP BY movie_id
), joined AS (
  SELECT b.id, b.title, b.release_date, b.overview, b.poster_path, b.backdrop_path, b.popularity, b.imdb_url, b.cinemagia_url, COALESCE(t.solo_friends,0) AS solo_friends, COALESCE(t.couple,0) AS couple, COALESCE(t.streaming,0) AS streaming, COALESCE(t.arr,0) AS arr
  FROM base b LEFT JOIN t ON t.movie_id = b.id
), keyed AS (
  SELECT id, title, release_date, overview, poster_path, backdrop_path, popularity, imdb_url, cinemagia_url, solo_friends, couple, streaming, arr, CASE
      WHEN $4::text = 'popularity' THEN popularity
      WHEN $4::text = 'release_date' THEN extract(epoch from release_date)
      WHEN $4::text = 'solo_friends' THEN solo_friends::double precision
      WHEN $4::text = 'couple' THEN couple::double precision
      WHEN $4::text = 'streaming' THEN streaming::double precision
      WHEN $4::text = 'arr' THEN arr::double precision
      ELSE popularity
    END AS key_value
  FROM joined
), voted AS (
  SELECT j.id, j.title, j.release_date, j.overview, j.poster_path, j.backdrop_path, j.popularity, j.imdb_url, j.cinemagia_url, j.solo_friends, j.couple, j.streaming, j.arr, j.key_value, COALESCE(v.category::text, '') AS voted_category
  FROM keyed j
  LEFT JOIN voters vr ON vr.fingerprint = $9
  LEFT JOIN votes v ON v.movie_id = j.id AND v.voter_id = vr.id
), paged AS (
  SELECT id, title, release_date, overview, poster_path, backdrop_path, popularity, imdb_url, cinemagia_url, solo_friends, couple, streaming, arr, key_value, voted_category FROM voted
  WHERE (
    $6::float8 IS NULL OR (
      CASE WHEN $5::text = 'desc'
           THEN (key_value < $6 OR (key_value = $6 AND id < $7::bigint))
           ELSE (key_value > $6 OR (key_value = $6 AND id > $7::bigint))
      END
    )
  )
)
SELECT id, title, release_date, overview, poster_path, backdrop_path, popularity, imdb_url, cinemagia_url,
       solo_friends, couple, streaming, arr, key_value, voted_category
FROM paged p
ORDER BY
  CASE WHEN $5::text = 'desc' THEN key_value END DESC NULLS LAST,
  CASE WHEN $5::text = 'asc'  THEN key_value END ASC  NULLS LAST,
  CASE WHEN $4::text <> 'popularity' THEN popularity END DESC NULLS LAST,
  CASE WHEN $5::text = 'desc' THEN p.id END DESC NULLS LAST,
  CASE WHEN $5::text = 'asc'  THEN p.id END ASC  NULLS LAST
LIMIT $8
`

type ListActiveMoviesFilteredPageParams struct {
	Column1     pgtype.Timestamptz `json:"column_1"`
	Column2     float64            `json:"column_2"`
	Column3     float64            `json:"column_3"`
	Column4     string             `json:"column_4"`
	Column5     string             `json:"column_5"`
	Column6     float64            `json:"column_6"`
	Column7     int64              `json:"column_7"`
	Limit       int32              `json:"limit"`
	Fingerprint string             `json:"fingerprint"`
}

type ListActiveMoviesFilteredPageRow struct {
	ID            int64         `json:"id"`
	Title         string        `json:"title"`
	ReleaseDate   pgtype.Date   `json:"release_date"`
	Overview      pgtype.Text   `json:"overview"`
	PosterPath    pgtype.Text   `json:"poster_path"`
	BackdropPath  pgtype.Text   `json:"backdrop_path"`
	Popularity    pgtype.Float8 `json:"popularity"`
	ImdbUrl       pgtype.Text   `json:"imdb_url"`
	CinemagiaUrl  pgtype.Text   `json:"cinemagia_url"`
	SoloFriends   int64         `json:"solo_friends"`
	Couple        int64         `json:"couple"`
	Streaming     int64         `json:"streaming"`
	Arr           int64         `json:"arr"`
	KeyValue      interface{}   `json:"key_value"`
	VotedCategory interface{}   `json:"voted_category"`
}

func (q *Queries) ListActiveMoviesFilteredPage(ctx context.Context, arg ListActiveMoviesFilteredPageParams) ([]ListActiveMoviesFilteredPageRow, error) {
	rows, err := q.db.Query(ctx, ListActiveMoviesFilteredPage,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Limit,
		arg.Fingerprint,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveMoviesFilteredPageRow{}
	for rows.Next() {
		var i ListActiveMoviesFilteredPageRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ReleaseDate,
			&i.Overview,
			&i.PosterPath,
			&i.BackdropPath,
			&i.Popularity,
			&i.ImdbUrl,
			&i.CinemagiaUrl,
			&i.SoloFriends,
			&i.Couple,
			&i.Streaming,
			&i.Arr,
			&i.KeyValue,
			&i.VotedCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListActiveMoviesPage = `-- name: ListActiveMoviesPage :many
SELECT id, title, release_date, overview, poster_path, backdrop_path, popularity, imdb_url, cinemagia_url
FROM movies
WHERE release_date >= date_trunc('month', $1::timestamptz)::date
  AND release_date <= (date_trunc('month', $1::timestamptz)::date + interval '1 month - 1 second')
  AND $1::timestamptz <= (release_date + interval '14 days')
  AND (
    $3::bigint = 0 OR (popularity < $2) OR (popularity = $2 AND id < $3)
  )
ORDER BY popularity DESC, id DESC
LIMIT $4
`

type ListActiveMoviesPageParams struct {
	Column1    pgtype.Timestamptz `json:"column_1"`
	Popularity pgtype.Float8      `json:"popularity"`
	Column3    int64              `json:"column_3"`
	Limit      int32              `json:"limit"`
}

type ListActiveMoviesPageRow struct {
	ID           int64         `json:"id"`
	Title        string        `json:"title"`
	ReleaseDate  pgtype.Date   `json:"release_date"`
	Overview     pgtype.Text   `json:"overview"`
	PosterPath   pgtype.Text   `json:"poster_path"`
	BackdropPath pgtype.Text   `json:"backdrop_path"`
	Popularity   pgtype.Float8 `json:"popularity"`
	ImdbUrl      pgtype.Text   `json:"imdb_url"`
	CinemagiaUrl pgtype.Text   `json:"cinemagia_url"`
}

func (q *Queries) ListActiveMoviesPage(ctx context.Context, arg ListActiveMoviesPageParams) ([]ListActiveMoviesPageRow, error) {
	rows, err := q.db.Query(ctx, ListActiveMoviesPage,
		arg.Column1,
		arg.Popularity,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveMoviesPageRow{}
	for rows.Next() {
		var i ListActiveMoviesPageRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ReleaseDate,
			&i.Overview,
			&i.PosterPath,
			&i.BackdropPath,
			&i.Popularity,
			&i.ImdbUrl,
			&i.CinemagiaUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMovieIDsByMonth = `-- name: ListMovieIDsByMonth :many
SELECT id
FROM movies
WHERE release_date >= date_trunc('month', $1::date)
  AND release_date <  (date_trunc('month', $1::date) + interval '1 month')
ORDER BY id
`

func (q *Queries) ListMovieIDsByMonth(ctx context.Context, dollar_1 pgtype.Date) ([]int64, error) {
	rows, err := q.db.Query(ctx, ListMovieIDsByMonth, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpsertMovie = `-- name: UpsertMovie :exec
INSERT INTO movies (id, title, release_date, overview, poster_path, backdrop_path, popularity, imdb_url, cinemagia_url)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (id) DO UPDATE SET
  title = EXCLUDED.title,
  release_date = EXCLUDED.release_date,
  overview = EXCLUDED.overview,
  poster_path = EXCLUDED.poster_path,
  backdrop_path = EXCLUDED.backdrop_path,
  popularity = EXCLUDED.popularity,
  imdb_url = EXCLUDED.imdb_url,
  cinemagia_url = EXCLUDED.cinemagia_url,
  updated_at = now()
`

type UpsertMovieParams struct {
	ID           int64         `json:"id"`
	Title        string        `json:"title"`
	ReleaseDate  pgtype.Date   `json:"release_date"`
	Overview     pgtype.Text   `json:"overview"`
	PosterPath   pgtype.Text   `json:"poster_path"`
	BackdropPath pgtype.Text   `json:"backdrop_path"`
	Popularity   pgtype.Float8 `json:"popularity"`
	ImdbUrl      pgtype.Text   `json:"imdb_url"`
	CinemagiaUrl pgtype.Text   `json:"cinemagia_url"`
}

func (q *Queries) UpsertMovie(ctx context.Context, arg UpsertMovieParams) error {
	_, err := q.db.Exec(ctx, UpsertMovie,
		arg.ID,
		arg.Title,
		arg.ReleaseDate,
		arg.Overview,
		arg.PosterPath,
		arg.BackdropPath,
		arg.Popularity,
		arg.ImdbUrl,
		arg.CinemagiaUrl,
	)
	return err
}
